// Generated by CoffeeScript 1.6.2
var EventEmitter, SSE, error, middleware, _extend, _typeCheck,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventEmitter = require('events').EventEmitter;

error = null;

_typeCheck = function(type, obj) {
  var cls;

  cls = Object.prototype.toString.call(obj).slice(8, -1);
  return obj !== void 0 && obj !== null && cls === type;
};

_extend = function(origin, add) {
  var key, keys, _i, _len;

  if (!add || !_typeCheck('Object', add)) {
    return origin;
  }
  keys = Object.keys(add);
  for (_i = 0, _len = keys.length; _i < _len; _i++) {
    key = keys[_i];
    origin[key] = add[key];
  }
  return origin;
};

SSE = (function(_super) {
  __extends(SSE, _super);

  SSE.defaultOptions = {
    retry: 5 * 1000,
    keepAlive: 15 * 1000
  };

  SSE.comment = function(comment, callback) {
    var serialized;

    serialized = ": " + comment + "\n\n";
    if (!callback) {
      return serialized;
    } else {
      return callback(error, serialized);
    }
  };

  SSE.retry = function(time, callback) {
    var serialized;

    serialized = "retry: " + time + "\n";
    if (!callback) {
      return serialized;
    } else {
      return callback(error, serialized);
    }
  };

  SSE.event = function(event, callback) {
    var serialized;

    serialized = event ? "event: " + event + "\n" : '';
    if (!callback) {
      return serialized;
    } else {
      return callback(error, serialized);
    }
  };

  SSE.id = function(id, callback) {
    var serialized;

    if (_typeCheck('Function', id)) {
      callback = id;
      id = null;
    }
    serialized = "id: " + (id ? id : (new Date()).getTime()) + "\n";
    if (!callback) {
      return serialized;
    } else {
      return callback(error, serialized);
    }
  };

  SSE.data = function(data, callback) {
    var piece, serialized, _i, _len;

    serialized = '';
    if (!(_typeCheck('String', data) && (data != null))) {
      data = JSON.stringify(data);
      serialized = data ? "data: " + data + "\n" : '';
    } else {
      data = data.split('\n');
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        piece = data[_i];
        serialized += "data: " + piece + "\n";
      }
    }
    if (serialized) {
      serialized += '\n';
    }
    if (!callback) {
      return serialized;
    } else {
      return callback(error, serialized);
    }
  };

  SSE.message = function(obj, callback) {
    var serialized;

    serialized = [this.id(obj.id), this.event(obj.event), this.data(obj.data)].join('');
    if (!callback) {
      return serialized;
    } else {
      return callback(error, serialized);
    }
  };

  SSE.headers = function(callback) {
    var headerDict;

    headerDict = {
      'Content-Type': 'text/event-stream; charset=utf-8',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Transfer-Encoding': 'identity'
    };
    if (!callback) {
      return headerDict;
    } else {
      return callback(error, headerDict);
    }
  };

  function SSE(req, res, options) {
    var _this = this;

    this.req = req;
    this.res = res;
    this.options = options != null ? options : {};
    this._dispatchMessage = __bind(this._dispatchMessage, this);
    this.sendRaw = __bind(this.sendRaw, this);
    this.sendData = __bind(this.sendData, this);
    this.sendId = __bind(this.sendId, this);
    this.sendEvent = __bind(this.sendEvent, this);
    this.sendRetry = __bind(this.sendRetry, this);
    this.sendComment = __bind(this.sendComment, this);
    this.options = _extend(this.constructor.defaultOptions, this.options);
    if (!this.res.headersSent) {
      this._writeHeaders();
    }
    this.emit('connected');
    if (options.retry) {
      this.sendRetry(options.retry);
    }
    /* XDomainRequest (MSIE8, MSIE9)
    */

    this.sendComment(Array(2049).join(' '));
    if (this.options.keepAlive) {
      this._keepAlive();
    }
    /* Remy Sharp's Polyfill support.
    */

    if (this.req.headers['x-requested-with'] === 'XMLHttpRequest') {
      this.res.xhr = null;
    }
    this.lastEventId = this.req.headers['last-event-id'] || null;
    if (this.lastEventId) {
      this.emit('reconnected');
    }
    this.res.once('close', function() {
      if (_this.intervalId) {
        clearInterval(_this.intervalId);
      }
      return _this.emit('disconnected');
    });
    this.emit('ready');
  }

  SSE.prototype.sendComment = function(comment) {
    return this.sendRaw(this.constructor.comment(comment));
  };

  SSE.prototype.sendRetry = function(time) {
    return this.sendRaw(this.constructor.retry(time));
  };

  SSE.prototype.sendEvent = function(event) {
    return this.sendRaw(this.constructor.event(event));
  };

  SSE.prototype.sendId = function(id) {
    return this.sendRaw(this.constructor.id(id));
  };

  SSE.prototype.sendData = function(data) {
    return this.sendRaw(this.constructor.data(data));
  };

  SSE.prototype.sendRaw = function(data) {
    return this.res.write(data);
  };

  SSE.prototype._processAndSendMessage = function(message) {
    return this.sendRaw(this.constructor.message(message));
  };

  SSE.prototype._dispatchMessage = function(message) {
    if (_typeCheck('Object', message)) {
      return this._processAndSendMessage(message);
    } else if (_typeCheck('String', message)) {
      return this.sendData(message);
    } else if (_typeCheck('Array', message)) {
      return message.forEach(function(msg) {
        return this._dispatchMessage(msg);
      });
    } else {
      throw new Error("Unparsable message. (" + message + ")");
    }
  };

  SSE.prototype._writeHeaders = function() {
    return this.res.writeHead(200, 'OK', this.constructor.headers());
  };

  SSE.prototype._keepAlive = function() {
    var schedule;

    schedule = function() {
      var _this = this;

      return setTimeout((function() {
        _this.sendComment("keepalive " + (Date.now()) + "\n\n");
        return _this.intervalId = schedule();
      }), this.options.keepAlive);
    };
    return this.intervalId = schedule();
  };

  return SSE;

})(EventEmitter);

/* Aliases
*/


SSE.prototype.pub = SSE.prototype._dispatchMessage;

SSE.prototype.publish = SSE.prototype._dispatchMessage;

SSE.prototype.send = SSE.prototype._dispatchMessage;

module.exports = SSE;

/* Connect/Express middleware
*/


middleware = function(req, res, options) {
  var callable;

  callable = function(message) {
    return this.sse.socket.publish(message);
  };
  callable.socket = new SSE(req, res, options);
  return callable;
};

module.exports.middleware = function(options) {
  /* Configuration, values in milliseconds
  */
  options.retry = (options != null ? options.retry : void 0) || 3 * 1000;
  options.keepAlive = (options != null ? options.keepAlive : void 0) || 15 * 1000;
  return function(req, res, next) {
    if (req.headers.accept === "text/event-stream") {
      res.sse = middleware(req, res, options);
    }
    return next();
  };
};
