// Generated by CoffeeScript 1.6.2
var EventEmitter, SSE, typeCheck, util,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventEmitter = require('events').EventEmitter;

util = require('util');

typeCheck = function(type, obj) {
  var cls;

  cls = Object.prototype.toString.call(obj).slice(8, -1);
  return obj !== void 0 && obj !== null && cls === type;
};

SSE = (function(_super) {
  __extends(SSE, _super);

  SSE.defaultOptions = {
    retry: 5 * 1000,
    keepAlive: 15 * 1000
  };

  SSE.comment = function(comment) {
    return ":" + comment + "\n\n";
  };

  SSE.retry = function(time) {
    return "retry: " + time + "\n";
  };

  SSE.event = function(event) {
    return "event: " + event + "\n";
  };

  SSE.id = function(id) {
    return "id: " + (id || (new Date()).getTime()) + "\n";
  };

  SSE.data = function(data) {
    if (!typeCheck('String', data)) {
      data = JSON.stringify(data);
    }
    return "data: " + data + "\n\n";
  };

  function SSE(req, res, options) {
    var callable,
      _this = this;

    this.req = req;
    this.res = res;
    this.options = options != null ? options : {};
    this._dispatchMessage = __bind(this._dispatchMessage, this);
    this._processMessage = __bind(this._processMessage, this);
    this.sendRaw = __bind(this.sendRaw, this);
    this.sendData = __bind(this.sendData, this);
    this.sendId = __bind(this.sendId, this);
    this.sendEvent = __bind(this.sendEvent, this);
    this.sendRetry = __bind(this.sendRetry, this);
    this.sendComment = __bind(this.sendComment, this);
    this.options = util._extend(this.constructor.defaultOptions, this.options);
    if (!this.res.headersSent) {
      this._writeHeaders();
    }
    this.emit('connected');
    this.sendRetry(options.retry);
    /* XDomainRequest (MSIE8, MSIE9)
    */

    this.sendComment(Array(2049).join(' '));
    if (this.options.keepAlive) {
      this._keepAlive();
    }
    /* Remy Sharp's Polyfill support.
    */

    if (this.req.headers['x-requested-with'] === 'XMLHttpRequest') {
      this.res.xhr = null;
    }
    this.lastEventId = this.req.headers['last-event-id'] || null;
    if (this.lastEventId) {
      this.emit('reconnected');
    }
    this.res.once('close', function() {
      if (_this.intervalId) {
        clearInterval(_this.intervalId);
      }
      return _this.emit('disconnected');
    });
    callable = function(message) {
      return _this.publish(message);
    };
    callable.socket = this;
    this.emit('ready');
    return callable;
  }

  SSE.prototype.sendComment = function(comment) {
    return this.res.write(this.constructor.comment(comment));
  };

  SSE.prototype.sendRetry = function(time) {
    return this.res.write(this.constructor.retry(time));
  };

  SSE.prototype.sendEvent = function(event) {
    return this.res.write(this.constructor.event(event));
  };

  SSE.prototype.sendId = function(id) {
    return this.res.write(this.constructor.id(id));
  };

  SSE.prototype.sendData = function(data) {
    return this.res.write(this.constructor.data(data));
  };

  SSE.prototype.sendRaw = function(data) {
    return this.res.write(data);
  };

  SSE.prototype._processMessage = function(obj) {
    var data, event, id, _ref;

    _ref = [this.constructor.id(obj.id), this.constructor.event(obj.event), this.constructor.data(obj.data)], id = _ref[0], event = _ref[1], data = _ref[2];
    return this.res.write(id + event + data);
  };

  SSE.prototype._dispatchMessage = function(message) {
    if (typeCheck('Object', message)) {
      return this._processMessage(message);
    } else if (typeCheck('String', message)) {
      return this.sendData(message);
    } else if (typeCheck('Array', message)) {
      return message.forEach(function(msg) {
        return this._dispatchMessage(msg);
      });
    } else {
      throw new Error("Unparsable message. (" + message + ")");
    }
  };

  SSE.prototype._writeHeaders = function() {
    this.res.charset = 'utf-8';
    this.res.statusCode = 200;
    this.res.setHeader("Content-Type", "text/event-stream");
    this.res.setHeader("Cache-Control", "no-cache");
    this.res.setHeader("Connection", "keep-alive");
    return this.res.setHeader("Transfer-Encoding", "identity");
  };

  SSE.prototype._keepAlive = function() {
    var _this = this;

    return this.intervalId = setInterval((function() {
      return _this.sendComment("KEEPALIVE " + (Date.now()) + "\n\n");
    }), this.options.keepAlive);
  };

  return SSE;

})(EventEmitter);

/* Aliases
*/


SSE.prototype.pub = SSE.prototype._dispatchMessage;

SSE.prototype.publish = SSE.prototype._dispatchMessage;

SSE.prototype.send = SSE.prototype._dispatchMessage;

module.exports = SSE;

/* Connect/Express middleware
*/


module.exports.middleware = function(options) {
  /* Configuration, values in milliseconds
  */
  options.retry = (options != null ? options.retry : void 0) || 3 * 1000;
  options.keepAlive = (options != null ? options.keepAlive : void 0) || 15 * 1000;
  return function(req, res, next) {
    if (req.headers.accept === "text/event-stream") {
      res.sse = new SSE(req, res, options);
    }
    return next();
  };
};
