// Generated by CoffeeScript 1.6.2
var EventEmitter, SSE, error, typeCheck, util,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventEmitter = require('events').EventEmitter;

util = require('util');

error = null;

typeCheck = function(type, obj) {
  var cls;

  cls = Object.prototype.toString.call(obj).slice(8, -1);
  return obj !== void 0 && obj !== null && cls === type;
};

SSE = (function(_super) {
  __extends(SSE, _super);

  SSE.defaultOptions = {
    retry: 5 * 1000,
    keepAlive: 15 * 1000
  };

  SSE.comment = function(comment, callback) {
    var serialized;

    serialized = ": " + comment + "\n\n";
    if (!callback) {
      return serialized;
    } else {
      return callback(error, serialized);
    }
  };

  SSE.retry = function(time, callback) {
    var serialized;

    serialized = "retry: " + time + "\n";
    if (!callback) {
      return serialized;
    } else {
      return callback(error, serialized);
    }
  };

  SSE.event = function(event, callback) {
    var serialized;

    serialized = event ? "event: " + event + "\n" : '';
    if (!callback) {
      return serialized;
    } else {
      return callback(error, serialized);
    }
  };

  SSE.id = function(id, callback) {
    var serialized;

    if (typeCheck('Function', id)) {
      callback = id;
      id = null;
    }
    serialized = "id: " + (id ? id : (new Date()).getTime()) + "\n";
    if (!callback) {
      return serialized;
    } else {
      return callback(error, serialized);
    }
  };

  SSE.data = function(data, callback) {
    var serialized;

    if (!typeCheck('String', data)) {
      data = JSON.stringify(data);
    }
    serialized = data ? "data: " + data + "\n\n" : '';
    if (!callback) {
      return serialized;
    } else {
      return callback(error, serialized);
    }
  };

  SSE.message = function(obj, callback) {
    var serialized;

    serialized = [this.id(obj.id), this.event(obj.event), this.data(obj.data)].join('');
    if (!callback) {
      return serialized;
    } else {
      return callback(error, serialized);
    }
  };

  SSE.headers = function(callback) {
    var headerDict;

    headerDict = {
      'Content-Type': 'text/event-stream; charset=utf-8',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Transfer-Encoding': 'identity'
    };
    if (!callback) {
      return headerDict;
    } else {
      return callback(error, headerDict);
    }
  };

  function SSE(req, res, options) {
    var callable,
      _this = this;

    this.req = req;
    this.res = res;
    this.options = options != null ? options : {};
    this._dispatchMessage = __bind(this._dispatchMessage, this);
    this.sendRaw = __bind(this.sendRaw, this);
    this.sendData = __bind(this.sendData, this);
    this.sendId = __bind(this.sendId, this);
    this.sendEvent = __bind(this.sendEvent, this);
    this.sendRetry = __bind(this.sendRetry, this);
    this.sendComment = __bind(this.sendComment, this);
    this.options = util._extend(this.constructor.defaultOptions, this.options);
    if (!this.res.headersSent) {
      this._writeHeaders();
    }
    this.emit('connected');
    this.sendRetry(options.retry);
    /* XDomainRequest (MSIE8, MSIE9)
    */

    this.sendComment(Array(2049).join(' '));
    if (this.options.keepAlive) {
      this._keepAlive();
    }
    /* Remy Sharp's Polyfill support.
    */

    if (this.req.headers['x-requested-with'] === 'XMLHttpRequest') {
      this.res.xhr = null;
    }
    this.lastEventId = this.req.headers['last-event-id'] || null;
    if (this.lastEventId) {
      this.emit('reconnected');
    }
    this.res.once('close', function() {
      if (_this.intervalId) {
        clearInterval(_this.intervalId);
      }
      return _this.emit('disconnected');
    });
    callable = function(message) {
      return _this.publish(message);
    };
    callable.socket = this;
    this.emit('ready');
    return callable;
  }

  SSE.prototype.sendComment = function(comment) {
    return this.sendRaw(this.constructor.comment(comment));
  };

  SSE.prototype.sendRetry = function(time) {
    return this.sendRaw(this.constructor.retry(time));
  };

  SSE.prototype.sendEvent = function(event) {
    return this.sendRaw(this.constructor.event(event));
  };

  SSE.prototype.sendId = function(id) {
    return this.sendRaw(this.constructor.id(id));
  };

  SSE.prototype.sendData = function(data) {
    return this.sendRaw(this.constructor.data(data));
  };

  SSE.prototype.sendRaw = function(data) {
    return this.res.write(data);
  };

  SSE.prototype._processAndSendMessage = function(message) {
    return this.sendRaw(this.constructor.message(message));
  };

  SSE.prototype._dispatchMessage = function(message) {
    if (typeCheck('Object', message)) {
      return this._processAndSendMessage(message);
    } else if (typeCheck('String', message)) {
      return this.sendData(message);
    } else if (typeCheck('Array', message)) {
      return message.forEach(function(msg) {
        return this._dispatchMessage(msg);
      });
    } else {
      throw new Error("Unparsable message. (" + message + ")");
    }
  };

  SSE.prototype._writeHeaders = function() {
    return this.res.writeHead(200, 'OK', this.constructor.headers());
  };

  SSE.prototype._keepAlive = function() {
    var _this = this;

    return this.intervalId = setInterval((function() {
      return _this.sendComment("keepalive " + (Date.now()) + "\n\n");
    }), this.options.keepAlive);
  };

  return SSE;

})(EventEmitter);

/* Aliases
*/


SSE.prototype.pub = SSE.prototype._dispatchMessage;

SSE.prototype.publish = SSE.prototype._dispatchMessage;

SSE.prototype.send = SSE.prototype._dispatchMessage;

module.exports = SSE;

/* Connect/Express middleware
*/


module.exports.middleware = function(options) {
  /* Configuration, values in milliseconds
  */
  options.retry = (options != null ? options.retry : void 0) || 3 * 1000;
  options.keepAlive = (options != null ? options.keepAlive : void 0) || 15 * 1000;
  return function(req, res, next) {
    if (req.headers.accept === "text/event-stream") {
      res.sse = new SSE(req, res, options);
    }
    return next();
  };
};
